<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>fplutil: fplutil::IndexAllocator&lt; Index &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
<script>
  /**
   * Check if the browser rendering this page is being run on an Android device.
   * It checks if the string 'android' is found in the browser's `userAgent`.
   * @return {boolean} This returns `true` if the browser's `userAgent` contains
   * the string 'android' (indicating that the browser is on an Android device).
   * Otherwise, it returns `false`.
   */
  function isAndroidDevice() {
    if (navigator && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().indexOf('android') != -1;
    } else {
      return false;
    }
  }
  /**
   * Check if an HTML `class` attribute is in the browser-specific format.
   * @param {string} An HTML `class` attribute in the format 'browser-{device}'.
   * @return {boolean} Returns `true` if `browserClass` was in the valid format,
   * prefixed with 'browser-'. Otherwise, it returns false.
   */
  function isBrowserSpecificClassName(browserClass) {
    if (browserClass && browserClass.substring(0, 8) == 'browser-' &&
        browserClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Get all the HTML Elements with browser-specific `class` attributes.
   * @return {array} Returns an array of all the HTML Elements with a `class`
   * attribute that is prefixed with `browser-`.
   */
  function getAllBrowserSpecificElements() {
    if (document) {
      var htmlElements = document.getElementsByTagName("*");
      var browserSpecificElements = [];
      for (var i = 0; i < htmlElements.length; i++) {
        if (isBrowserSpecificClassName(htmlElements[i].className)) {
          browserSpecificElements.push(htmlElements[i]);
        }
      }
      return browserSpecificElements;
    } else {
      return null;
    }
  }
  /**
   * Given a browser-specific HTML `class` attribute, extract the device name.
   * @param {string} browserClass The string name of an HTML `class` attribute,
   * in the format `browser-{device}`.
   * @return {string} Returns a string containing only the device portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractDeviceFromBrowserClass(browserClass) {
    if (isBrowserSpecificClassName(browserClass)) {
      return browserClass.substring(8);
    }
    else {
      return null;
    }
  }
  /**
   * Hide device specific elements that do not apply to the current device.
   */
  function handleDeviceSpecificLoading() {
    var browserSpecificElements = getAllBrowserSpecificElements();
    for (var i = 0; i < browserSpecificElements.length; i++) {
      var device = extractDeviceFromBrowserClass(browserSpecificElements[i].className);
      if (device && !isAndroidDevice() && device == 'android') {
        browserSpecificElements[i].innerHTML = '';
      } else if(device && isAndroidDevice() && device == 'desktop') {
        browserSpecificElements[i].innerHTML = '';
      }
    }
  }
  $(document).ready(handleDeviceSpecificLoading);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">fplutil
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="fplutil_prerequisites.html"><span>Prerequisites</span></a></li>
      <li><a href="libfplutil_overview.html"><span>libfplutil</span></a></li>
      <li><a href="android_ndk_perf.html"><span>android_ndk_perf.py</span></a></li>
      <li><a href="build_all_android.html"><span>build_all_android.py</span></a></li>
      <li><a href="buildutil_overview.html"><span>buildutil</span></a></li>
      <li><a href="md_readme.html#fplutil_readme"><span>readme</span></a></li>
      <li><a href="contributing.html"><span>contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfplutil_1_1_index_allocator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfplutil_1_1_index_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fplutil::IndexAllocator&lt; Index &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allocate, free, and defragment array indices.  
 <a href="classfplutil_1_1_index_allocator.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="index__allocator_8h_source.html">fplutil/index_allocator.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator_1_1_callback_interface.html">CallbackInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator_1_1_index_range.html">IndexRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac781a2a77b68f65b906407752c9e7558"><td class="memItemLeft" align="right" valign="top">typedef Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#ac781a2a77b68f65b906407752c9e7558">Count</a></td></tr>
<tr class="separator:ac781a2a77b68f65b906407752c9e7558"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b3f055522385215262d417a81a77dc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a1b3f055522385215262d417a81a77dc6">IndexAllocator</a> (<a class="el" href="classfplutil_1_1_index_allocator_1_1_callback_interface.html">CallbackInterface</a> &amp;callbacks)</td></tr>
<tr class="separator:a1b3f055522385215262d417a81a77dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5118a94eb48a52503e70b24f157f14"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a4f5118a94eb48a52503e70b24f157f14">Alloc</a> (<a class="el" href="classfplutil_1_1_index_allocator.html#ac781a2a77b68f65b906407752c9e7558">Count</a> count)</td></tr>
<tr class="separator:a4f5118a94eb48a52503e70b24f157f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090a71f86a21cbe6a0e790120b5ef757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a090a71f86a21cbe6a0e790120b5ef757">Free</a> (Index index)</td></tr>
<tr class="separator:a090a71f86a21cbe6a0e790120b5ef757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e4689c9194fe1b363c0657a89c2662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e4689c9194fe1b363c0657a89c2662"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>UnusedAtEnd</b> () const </td></tr>
<tr class="separator:a48e4689c9194fe1b363c0657a89c2662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171d40d44753056887ae27527dd2e46b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment</a> ()</td></tr>
<tr class="separator:a171d40d44753056887ae27527dd2e46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df9706f52af6f4efc858b6a07bfd7a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df9706f52af6f4efc858b6a07bfd7a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a6df9706f52af6f4efc858b6a07bfd7a3">Empty</a> () const </td></tr>
<tr class="memdesc:a6df9706f52af6f4efc858b6a07bfd7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no indices allocated. <br /></td></tr>
<tr class="separator:a6df9706f52af6f4efc858b6a07bfd7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef505f49c171279706ef498e98c0e7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ef505f49c171279706ef498e98c0e7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a8ef505f49c171279706ef498e98c0e7a">ValidIndex</a> (Index index) const </td></tr>
<tr class="memdesc:a8ef505f49c171279706ef498e98c0e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the index is current allocated. <br /></td></tr>
<tr class="separator:a8ef505f49c171279706ef498e98c0e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b054d9a0ab898307098054e3ae3188"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a40b054d9a0ab898307098054e3ae3188">NumUnusedIndices</a> () const </td></tr>
<tr class="separator:a40b054d9a0ab898307098054e3ae3188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c3b9696e1a0eebfa6cbf414d7b69d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplutil_1_1_index_allocator.html#ac781a2a77b68f65b906407752c9e7558">Count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a3c5c3b9696e1a0eebfa6cbf414d7b69d">CountForIndex</a> (Index index) const </td></tr>
<tr class="separator:a3c5c3b9696e1a0eebfa6cbf414d7b69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a974c7e9a6630fc907cbdfd5cf1158d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a3a974c7e9a6630fc907cbdfd5cf1158d">VerifyInternalState</a> () const </td></tr>
<tr class="separator:a3a974c7e9a6630fc907cbdfd5cf1158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9648974205dbd13252ed8aaa4d026be7"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplutil_1_1_index_allocator.html#a9648974205dbd13252ed8aaa4d026be7">num_indices</a> () const </td></tr>
<tr class="separator:a9648974205dbd13252ed8aaa4d026be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Index&gt;<br />
class fplutil::IndexAllocator&lt; Index &gt;</h3>

<p>Allocate, free, and defragment array indices. </p>
<h1>Purpose </h1>
<p>Allocate and free indices into an array. Tries to keep the array as small as possible by recycling indices that have been freed.</p>
<h1>Example Usage </h1>
<p>We have an array of items that we would like to process with SIMD instructions. Items can be added and deleted from the array though. We don't want many unused indices in the array, since these holes still have to be processed with SIMD (which processes indices in groups of 4 or 8 or 16).</p>
<p>The <a class="el" href="classfplutil_1_1_index_allocator.html" title="Allocate, free, and defragment array indices. ">IndexAllocator</a> is great for this situation since you can call <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> before running the SIMD algorithm. The <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> call will backfill unused indices and ensure the data is contiguous.</p>
<h1>Details </h1>
<p>Periodically, you can call <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> to backfill indices that have been freed with the largest indices. This minimizes the length of the array, and more importantly makes the array data contiguous.</p>
<p>During <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> when an index is moved, a callback CallbackInterface::MoveIndex() is called so that the user can move the corresponding data.</p>
<p>Whenever the array size is increased (durring <a class="el" href="classfplutil_1_1_index_allocator.html#a4f5118a94eb48a52503e70b24f157f14">Alloc()</a>) or decreased (during <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a>), a callback CallbackInterface::SetNumIndices() is called so that the user can grow or shrink the corresponding data. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac781a2a77b68f65b906407752c9e7558"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Index <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::<a class="el" href="classfplutil_1_1_index_allocator.html#ac781a2a77b68f65b906407752c9e7558">Count</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of indices to allocate. Same base type as Index, since the <code>counts_</code> array can be as long as the largest index. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1b3f055522385215262d417a81a77dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::<a class="el" href="classfplutil_1_1_index_allocator.html">IndexAllocator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfplutil_1_1_index_allocator_1_1_callback_interface.html">CallbackInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>callbacks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an empty <a class="el" href="classfplutil_1_1_index_allocator.html" title="Allocate, free, and defragment array indices. ">IndexAllocator</a> that uses the specified callback interface. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4f5118a94eb48a52503e70b24f157f14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::Alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfplutil_1_1_index_allocator.html#ac781a2a77b68f65b906407752c9e7558">Count</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a previously-freed index can be recycled, allocates that index. Otherwise, increases the total number of indices by <code>count</code>, and return the first new index. When the number of indices is increased, the SetNumIndices() callback is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of indices in this allocation. Each block of allocated indices is kept contiguous during <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> calls. The index returned is the first index in the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c5c3b9696e1a0eebfa6cbf414d7b69d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplutil_1_1_index_allocator.html#ac781a2a77b68f65b906407752c9e7558">Count</a> <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::CountForIndex </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <code>count</code> value specified in Alloc. That is, the number of consecutive indices associated with <code>index</code>. </p>

</div>
</div>
<a class="anchor" id="a171d40d44753056887ae27527dd2e46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::Defragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backfill all unused index blocks. That is, move index blocks around until all the unused index blocks have the <em>highest</em> indices. Then, shrink the number of indices to remove all unused index blocks.</p>
<p>Every time we move an index block, we call callbacks_-&gt;MoveIndexRange(). In MoveIndexRange(), the callee can correspondingly move its internal data around to match the index shuffle. At the end of Degragment(), the callee's internal data will be contiguous. Contiguous data is essential in data-oriented design, since it minimizes cache misses.</p>
<p>Note that we could eliminate <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> function by calling MoveIndex() from <a class="el" href="classfplutil_1_1_index_allocator.html#a090a71f86a21cbe6a0e790120b5ef757">Free()</a>. The code would be simpler. We move the indices lazily, however, for performance: <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> is something that can happen on a background thread.</p>
<p>This function has worst case runtime of O(n) index moves, where n is the total number of indices. To see why, notice that indices are only moved forward, and are always moved into the forward-most hole.</p>
<p>Note that there is some inefficiency with setting the <code>count_</code> array excessively. The worst-case number of operations on the <code>count_</code> array is greater than O(n). However, the assumption is that since <code>count_</code> is just an array of integers, operations on it are insignificant compared to the actual data movement that happens in callbacks_-&gt;MoveIndexRange(). However, there is an optimization opportunity here, most likely.</p>
<p>In practice, this function will normally perform much better than O(n) moves. We endeavour to fill holes with index blocks near the end of the array. That is, we try to leapfrog the hole to the end of the array when possible.</p>
<p>Because of this, when all allocations are the same size, the worst case runtime improves significantly to O(k) index moves, where k is the total number of <em>unused</em> indices.</p>
<p>If moving an index is cheaper than processing data for an index, then you should call <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a> right before you process data, for optimal performance.</p>
<p>Note that the number of indices shrinks or stays the same in this function, so the final call to SetNumIndices() will never result in a reallocation of the underlying array (which would be slow). </p>

</div>
</div>
<a class="anchor" id="a090a71f86a21cbe6a0e790120b5ef757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::Free </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recycle 'index'. It will be used in the next allocation, or backfilled in the next call to <a class="el" href="classfplutil_1_1_index_allocator.html#a171d40d44753056887ae27527dd2e46b">Defragment()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to be freed. Must be in the range [0, num_indices_ - 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9648974205dbd13252ed8aaa4d026be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::num_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the array that number of contiguous indices. This includes all the indices that have been free. </p>

</div>
</div>
<a class="anchor" id="a40b054d9a0ab898307098054e3ae3188"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::NumUnusedIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of wasted indices. These holes will be plugged when Degragment() is called. </p>

</div>
</div>
<a class="anchor" id="a3a974c7e9a6630fc907cbdfd5cf1158d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfplutil_1_1_index_allocator.html">fplutil::IndexAllocator</a>&lt; Index &gt;::VerifyInternalState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assert if the internal state is invalid in any way. Sanity check on this data structure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="index__allocator_8h_source.html">index_allocator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
