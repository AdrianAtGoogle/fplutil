<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fplutil: fpl::IndexAllocator&lt; Index, Count &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fplutil
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="fplutil_prerequisites.html"><span>Prerequisites</span></a></li>
      <li><a href="libfplutil_overview.html"><span>libfplutil</span></a></li>
      <li><a href="android_ndk_perf.html"><span>android_ndk_perf.py</span></a></li>
      <li><a href="build_all_android.html"><span>build_all_android.py</span></a></li>
      <li><a href="buildutil_overview.html"><span>buildutil</span></a></li>
      <li><a href="md_readme.html#fplutil_readme"><span>readme</span></a></li>
      <li><a href="contributing.html"><span>contributing</span></a></li>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfpl_1_1_index_allocator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfpl_1_1_index_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fpl::IndexAllocator&lt; Index, Count &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allocate, free, and defragment array indices.  
 <a href="classfpl_1_1_index_allocator.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="index__allocator_8h_source.html">fplutil/index_allocator.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator_1_1_callback_interface.html">CallbackInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a779acf8075f36b16a0a33fed32fce850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#a779acf8075f36b16a0a33fed32fce850">IndexAllocator</a> (<a class="el" href="classfpl_1_1_index_allocator_1_1_callback_interface.html">CallbackInterface</a> &amp;callbacks)</td></tr>
<tr class="separator:a779acf8075f36b16a0a33fed32fce850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e07ecbcf2ea1d4d31e1e140c3648d97"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#a1e07ecbcf2ea1d4d31e1e140c3648d97">Alloc</a> (Count count)</td></tr>
<tr class="separator:a1e07ecbcf2ea1d4d31e1e140c3648d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b4ac64c11e067691b8e867f1ecbe02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#a79b4ac64c11e067691b8e867f1ecbe02">Free</a> (Index index)</td></tr>
<tr class="separator:a79b4ac64c11e067691b8e867f1ecbe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800dc069a9d8c9bf96a1aa52fab49b25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment</a> ()</td></tr>
<tr class="separator:a800dc069a9d8c9bf96a1aa52fab49b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad001f31a1eaeb8eb8a07030ffef5720c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad001f31a1eaeb8eb8a07030ffef5720c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#ad001f31a1eaeb8eb8a07030ffef5720c">Empty</a> () const </td></tr>
<tr class="memdesc:ad001f31a1eaeb8eb8a07030ffef5720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no indices allocated. <br/></td></tr>
<tr class="separator:ad001f31a1eaeb8eb8a07030ffef5720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ed06a18aec22b1a4b3b9b9656f9a32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ed06a18aec22b1a4b3b9b9656f9a32"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#a38ed06a18aec22b1a4b3b9b9656f9a32">ValidIndex</a> (Index index) const </td></tr>
<tr class="memdesc:a38ed06a18aec22b1a4b3b9b9656f9a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the index is current allocated. <br/></td></tr>
<tr class="separator:a38ed06a18aec22b1a4b3b9b9656f9a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e1b0c910c3b531ebed26f384442509"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#a23e1b0c910c3b531ebed26f384442509">NumUnusedIndices</a> () const </td></tr>
<tr class="separator:a23e1b0c910c3b531ebed26f384442509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa753fe222444bcae6fe77e2e95857d5"><td class="memItemLeft" align="right" valign="top">Count&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#afa753fe222444bcae6fe77e2e95857d5">CountForIndex</a> (Index index) const </td></tr>
<tr class="separator:afa753fe222444bcae6fe77e2e95857d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada7c95c55ca94835eeaea66a87103f3"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_index_allocator.html#aada7c95c55ca94835eeaea66a87103f3">num_indices</a> () const </td></tr>
<tr class="separator:aada7c95c55ca94835eeaea66a87103f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Index, class Count&gt;<br/>
class fpl::IndexAllocator&lt; Index, Count &gt;</h3>

<p>Allocate, free, and defragment array indices. </p>
<h1>Purpose </h1>
<p>Allocate and free indices into an array. Tries to keep the array as small as possible by recycling indices that have been freed.</p>
<h1>Example Usage </h1>
<p>We have an array of items that we would like to process with SIMD instructions. Items can be added and deleted from the array though. We don't want many unused indices in the array, since these holes still have to be processed with SIMD (which processes indices in groups of 4 or 8 or 16).</p>
<p>The <a class="el" href="classfpl_1_1_index_allocator.html" title="Allocate, free, and defragment array indices. ">IndexAllocator</a> is great for this situation since you can call <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> before running the SIMD algorithm. The <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> call will backfill unused indices and ensure the data is contiguous.</p>
<h1>Details </h1>
<p>Periodically, you can call <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> to backfill indices that have been freed with the largest indices. This minimizes the length of the array, and more importantly makes the array data contiguous.</p>
<p>During <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> when an index is moved, a callback CallbackInterface::MoveIndex() is called so that the user can move the corresponding data.</p>
<p>Whenever the array size is increased (durring <a class="el" href="classfpl_1_1_index_allocator.html#a1e07ecbcf2ea1d4d31e1e140c3648d97">Alloc()</a>) or decreased (during <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a>), a callback CallbackInterface::SetNumIndices() is called so that the user can grow or shrink the corresponding data. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a779acf8075f36b16a0a33fed32fce850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::<a class="el" href="classfpl_1_1_index_allocator.html">IndexAllocator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfpl_1_1_index_allocator_1_1_callback_interface.html">CallbackInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>callbacks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an empty <a class="el" href="classfpl_1_1_index_allocator.html" title="Allocate, free, and defragment array indices. ">IndexAllocator</a> that uses the specified callback interface. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1e07ecbcf2ea1d4d31e1e140c3648d97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::Alloc </td>
          <td>(</td>
          <td class="paramtype">Count&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a previously-freed index can be recycled, allocates that index. Otherwise, increases the total number of indices by <code>count</code>, and return the first new index. When the number of indices is increased, the SetNumIndices() callback is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of indices in this allocation. Each block of allocated indices is kept contiguous during <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> calls. The index returned is the first index in the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa753fe222444bcae6fe77e2e95857d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Count <a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::CountForIndex </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <code>count</code> value specified in Alloc. That is, the number of consecutive indices associated with <code>index</code>. </p>

</div>
</div>
<a class="anchor" id="a800dc069a9d8c9bf96a1aa52fab49b25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::Defragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backfill all unused indices with the largest indices by calling callbacks_-&gt;MoveIndex(). This reduces the total number of indices, and keeps memory contiguous. Contiguous memory is important to mimimize cache misses.</p>
<p>Note that we could eliminate <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> function by calling MoveIndex() from <a class="el" href="classfpl_1_1_index_allocator.html#a79b4ac64c11e067691b8e867f1ecbe02">Free()</a>. The code would be simpler. We move the indices lazily, however, for performance: <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> is something that can happen on a background thread.</p>
<p>This function is fairly cheap. If there are N holes, then there will be <b>at most</b> N calls to MoveIndex(). We assume that moving an index is cheaper than processing data for an index. So, you should <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a> right before you process data, for optimal performance.</p>
<p>Note that the number of indices shrinks or stays the same in this function, so the final call to SetNumIndices() will never result in a reallocation of the underlying array (which would be slow). </p>

</div>
</div>
<a class="anchor" id="a79b4ac64c11e067691b8e867f1ecbe02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::Free </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recycle 'index'. It will be used in the next allocation, or backfilled in the next call to <a class="el" href="classfpl_1_1_index_allocator.html#a800dc069a9d8c9bf96a1aa52fab49b25">Defragment()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to be freed. Must be in the range [0, num_indices_ - 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aada7c95c55ca94835eeaea66a87103f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::num_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the array that number of contiguous indices. This includes all the indices that have been free. </p>

</div>
</div>
<a class="anchor" id="a23e1b0c910c3b531ebed26f384442509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class Count &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classfpl_1_1_index_allocator.html">fpl::IndexAllocator</a>&lt; Index, Count &gt;::NumUnusedIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of wasted indices. These holes will be plugged when Degragment() is called. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="index__allocator_8h_source.html">index_allocator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
